# 📌 数组双指针（Two Pointers on Array）— 系统封档总结

> 目标：  
> - 真正理解数组双指针的**底层模型**
> - 能一眼判断**什么时候该用哪一种双指针**
> - 在 LeetCode / 面试中**稳定写对**

---

## 一、数组双指针的本质

数组双指针并不是一种算法，而是 **一类“原地构建结果”的思维方式**。

核心问题只有一个：

> **我如何在不额外开数组的情况下，  
> 一边扫描原数组，一边构造合法的结果？**

---

## 二、双指针的三大模型（完整分类）

### 1️⃣ 同向双指针（快慢指针）

**适用问题：**
- 过滤元素
- 去重
- 原地构建结果前缀

#### 👉 核心不变量
> `[0, slow)` 始终是一个**合法的结果数组前缀**

#### 👉 指针角色
- `fast`：扫描原数组
- `slow`：结果数组的**右边界 / 下一个写入位置**

---

### 2️⃣ 左右夹逼双指针

**适用问题：**
- 两端比较
- 最大 / 最小值来自数组两侧
- 顺序被运算破坏（如平方）

#### 👉 核心不变量
> `res[write+1 ... end]` 已经是**确定、有序的结果**

#### 👉 指针角色
- `left`：左端
- `right`：右端
- `write`：从后向前填结果

---

### 3️⃣ 滑动窗口（下一阶段）

> 本质：**区间不变量**  
> （尚未封档，后续补充）

---

## 三、同向双指针的三种经典形态

---

### ✅ 1. 过滤型（LeetCode 27 / 283）

**问题特征：**
- 删除 / 忽略某类元素
- 不关心尾部垃圾数据

#### 不变量
```text
[0, slow) = 所有被保留的元素
```

#### 模板
```python
slow = 0
for fast in range(n):
    if nums[fast] 满足保留条件:
        nums[slow] = nums[fast]
        slow += 1
return slow
```

---

### ✅ 2. 去重型（LeetCode 26）

**问题特征：**
- 有序数组
- 每个元素只允许出现 1 次

#### 不变量
```text
[0, slow) = 去重后的有序结果数组
```

#### 判断逻辑
```python
nums[fast] != nums[slow - 1]
```

---

### ✅ 3. k 次去重（LeetCode 80 / 通用模型）

**问题特征：**
- 有序数组
- 每个元素最多允许出现 k 次

#### 不变量（通用）
```text
[0, slow) = 有序结果数组，每个元素出现次数 ≤ k
```

#### 核心判断（灵魂）
```python
nums[fast] != nums[slow - k]
```

#### 通用模板
```python
if n <= k:
    return n

slow = k
for fast in range(k, n):
    if nums[fast] != nums[slow - k]:
        nums[slow] = nums[fast]
        slow += 1

return slow
```

---

## 四、左右夹逼双指针（LeetCode 977）

### 问题特征
- 原数组有序
- 运算（平方）破坏单调性
- 最大值一定来自数组两端

### 核心直觉
> **平方后的最大值只可能来自左右两端**

### 不变量
```text
res[write+1 ... end] 已经是排好序的平方结果
```

### 模板
```python
left, right = 0, n - 1
for write in range(n - 1, -1, -1):
    if abs(nums[left]) > abs(nums[right]):
        res[write] = nums[left] ** 2
        left += 1
    else:
        res[write] = nums[right] ** 2
        right -= 1
```

---

## 五、最重要的“判断口诀”

### ✅ 一眼判断该用哪种双指针

- **原地 + 构建前缀结果** → 同向快慢指针  
- **有序 + 限制重复次数** → k 次去重模板  
- **两端决定最大 / 最小** → 左右夹逼  
- **区间动态变化** → 滑动窗口

---

## 六、最容易犯的错误（高频雷区）

❌ 把 `slow` 当成“当前元素下标”  
❌ 用 `fast` 的位置推断结果数组状态  
❌ slow 跳着走（`+= 2 / += k`）  
❌ 忘记“结果数组”才是真正的判断对象  

---

## 七、阶段性毕业声明

- 数组双指针（过滤 / 去重 / k 次）：✅ 毕业  
- 左右夹逼双指针：✅ 毕业  
- 模型化、不变量思维：✅ 已内化  

👉 **你已经不再是“刷题的人”，而是在“用模型解题”。**

---

## 八、下一步建议

- 📦 滑动窗口（区间不变量）
- 🔍 二分查找（边界 + 单调性）
- 🧠 把双指针迁移到：字符串 / 链表

（后续章节待补充）
